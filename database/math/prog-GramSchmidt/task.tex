% !TeX spellcheck = en_US
\textbf{Gram-Schmidt algorithm ($QR$ factorization)}\\

%{\color{navy}
%The Gram-Schmidt algorithm is an algorithm that can be used to compute a reduced (sometimes also called ``thin'' or ``economic'') QR-decomposition of a matrix $A \in \mathbb{R}^{m\times n}$ with $m\geq n$ and $\text{rank}(A) = n$, i.e., of a matrix whose columns are linearly independent.\\
%The basic idea is to successively 
%built up an orthonormal system from a given set of linearly independent vectors; in our case the columns of 
%$A = [a_1, \dots, a_n] \in \mathbb{R}^{m\times n}$.
%We choose the first column as starting point for the algorithm and set $\widetilde{q_1} := a_1$. 
%Of course, in order to generate an orthogonal matrix $Q$ we have to rescale the vector and set
%$q_1 := \frac{\widetilde{q_1}}{\| \widetilde{q_1} \|}$.
%The successive vectors $\widetilde{q}_k$ are generated by
%subtracting all the ``shares'' $a_k^\top q_\ell\cdot q_\ell$ (=$\text{proj}_{q_\ell}(a_k)$) of the previous vectors $q_\ell$ from the column $a_k$, i.e.,
%$$
%\widetilde{q}_k := a_k - \sum_{\ell = 1}^{k-1} a_k^\top q_\ell \,\, q_\ell.
%$$
%The following algorithm computes a \textit{reduced} QR-decomposition of some matrix $A \in \mathbb{R}^{m \times n}$.\\
%\hspace*{1cm}\begin{minipage}{0.8\textwidth}
%	\begin{algorithm}[H]
%		$r_{11} = \| a_1 \|$\\
%		$q_1 = \frac{a_1}{r_{11}}$\\
%		\For{ $k = 2, \dots, n$ }{ 
%			\For{ $\ell = 1,\dots, k-1$}{  
%				$r_{\ell k} = a_k^\top q_\ell$	\\
%				
%			} 
%			$\widetilde{q}_k = a_k - \sum _{\ell=1}^{k-1} r_{\ell k} \, q_\ell$\\
%			$r_{kk} = \| \widetilde{q}_k \|$\\
%			$q_k = \frac{\widetilde{q}_k}{r_{kk}}$
%		}
%	\end{algorithm}
%\end{minipage}
%}
Assume that $A \in \mathbb{R}^{m \times n}$ has full column rank, i.e., $\text{rank}(A) = n$ (or equivalently $\text{kernel}(A)=\{0\}$). Then the classical Gram Schmidt algorithm to compute a \textit{reduced} QR-decomposition of $A$ can be implemented as follows:\\
\hspace*{1cm}\begin{minipage}{0.8\textwidth}
	\begin{algorithm}[H]
		$r_{11} = \| a_1 \|$\\
		$q_1 = \frac{a_1}{r_{11}}$\\
		\For{ $k = 2, \dots, n$ }{ 
			\For{ $\ell = 1,\dots, k-1$}{  
				$r_{\ell k} = a_k^\top q_\ell$	\\
				
			} 
			$\widetilde{q}_k = a_k - \sum _{\ell=1}^{k-1} r_{\ell k} \, q_\ell$\\
			$r_{kk} = \| \widetilde{q}_k \|$\\
			$q_k = \frac{\widetilde{q}_k}{r_{kk}}$
		}
	\end{algorithm}
\end{minipage}
~\\
\textbf{Task:} 
\begin{enumerate}
	\item Implement this algorithm as a function \verb|Q, R = qr_factor(A)|, which takes a matrix $A$ as input and returns the matrices $\widehat{Q}$ and $\widehat{R}$.
	\item Legendre polynomials: Run your algorithm on the following example:
	\begin{enumerate}
		\item Find a NumPy function to generate an equidistant grid on the interval $(-1,1)$.
		\item Find a NumPy function to generate a Vandermonde matrix \texttt{A} based on this grid.
		\item Compute \texttt{Q,R = qr\_factor(A)} and plot the columns of \texttt{A} and \texttt{Q} over the interval $(-1,1)$ into a one figure.
		\item Compute $\widehat{Q}^\top \widehat{Q}$ and $\widehat{Q}\widehat{R} - A$ and check whether the first yields the identity and the latter the zero-matrix.\\
		\textit{Hint: } You can use \texttt{numpy.allclose()} to check whether two \texttt{numpy.ndarray}'s are equal up to a certain tolerance.
	\end{enumerate} 
	\item Find a SciPy function to compute a $QR$ factorization (for the reduced $QR$ you may need to set the parameters accordingly).
\end{enumerate}

