\section{Matrix-Vector Product for a Sparse Matrix}
Consider the matrix $A \in \mathbb{R}^{n \times n}$ given by 
$$A = \begin{pmatrix}
2 & -1 		& 0  &\cdots & 0\\
-1 & 2 		& -1  &\ddots &  \vdots\\
 0 & \ddots  		&\ddots   	 &\ddots  & 0 \\
\vdots    & \ddots  		&-1  	 &2 & -1\\
0 & \cdots 	&  0  &-1 & 2\\
\end{pmatrix}$$

and implement the matrix-vector product $A \cdot x$ for some vector $x\in \mathbb{R}^n$ in three different ways:

\begin{enumerate}	
	\item Implement the matrix $A$ as a \verb|numpy.ndarray| and define a function \verb|dense(x)| which computes and outputs the numpy 			matrix-vector product \verb|A@x|. Print the number of Gbytes which are needed to store the matrix (you can use the attribute \verb|A.nbytes|).
	\item Implement a function \verb|matfree(x)| which outputs the matrix-vector product $A \cdot x$ without using the matrix $A$ explicitly.
	\item The ``correct'' way in Python: Use the modul \texttt{scipy.sparse} to implement the matrix $A$ in CSR (compressed sparse row) format and define a function \verb|sparse(x)| which computes and outputs the matrix-vector product using this CSR object. Print the number of Gbytes which are needed to store the matrix in CSR format (have a look at: \texttt{A.data}, \texttt{A.indptr}, \texttt{A.indices}).
\end{enumerate}
Play around with the dimension $n$ and measure the time which is needed in each way to compute the matrix-vector product for a random input vector \verb|x = numpy.random.rand(n)|.\\

\textit{Hint:} In the IPython shell you can simply use the \textit{magic function} \verb|%timeit| to measure the time for a certain operation. For example, you can type \verb|%timeit dense(x)|.  
