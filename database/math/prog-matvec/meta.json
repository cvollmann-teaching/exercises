{
    "filename": "prog-matvec.tex",
    "title": "",
    "subtitle": "",
    "coding": "",
    "mathFields": "",
    "tags": "Linear Algebra, Python",
    "relatedExercises": "",
    "solutionLength": "",
    "task": "\\textbf{The Matrix-Vector Product}\n\nImplement a function that takes as input a matrix $A \\in \\mathbb{R}^{m\\times n}$ and a vector $x \\in \\mathbb{R}^{n}$ and returns the matrix-vector product $Ax$.\n~\\\\\n\nImplement the following four ways:\n\\begin{enumerate}\t\n\t\\item \\textbf{Dense:} Input expected as \\verb|numpy.ndarray|:\\\\\n\t\t  Assume that the matrix and the vector are delivered to your function as \\verb|numpy.ndarray|.\n\t\\begin{enumerate}\n\t\t\\item Implement the matrix-vector product ``by hand'' using for loops, i.e., \\textit{without} using \\verb|numpy.dot(A,x)| (or \\verb|numpy.matmul(A,x)| or \\verb|A@x|).\n\t\t\\item Implement the matrix-vector product using \\texttt{A.dot(x)}, \\verb|A@x|, \\verb|numpy.matmul(A,x)| or \\verb|numpy.dot(A,x)|. \n\t\\end{enumerate}\n\t\\item \\textbf{Sparse:} Matrix expected in \\hyperref{https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_row_(CSR,_CRS_or_Yale_format)}{}{}{CSR format}:\\\\\n\tAssume that the matrix is delivered to your function as \\hyperref{https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.html}{}{}{\\texttt{scipy.sparse.csr\\_matrix}} object. The vector $x$ can either be expected as \\verb|numpy.ndarray| or simply as a Python \\texttt{list}. \t\n\t\\begin{enumerate}\n\t\t\\item Access the three CSR lists via \\texttt{A.data, A.indptr, A.indices} and implement the matrix-vector product ``by hand'' using for loops.\n\t\t\\item Implement the matrix-vector product using \\texttt{A.dot(x)} or \\texttt{A@x} . %Print the number of Gbytes which are needed to store the matrix in CSR format (have a look at: \\texttt{A.data}, \\texttt{A.indptr}, \\texttt{A.indices}).\n\t\\end{enumerate}\n\\end{enumerate}\n\n\nTest your different routines on the matrix $A \\in \\mathbb{R}^{n \\times n}$ given by \n$$A = \\begin{pmatrix}\n2 & -1 \t\t& 0  &\\cdots & 0\\\\\n-1 & 2 \t\t& -1  &\\ddots &  \\vdots\\\\\n0 & \\ddots  \t\t&\\ddots   \t &\\ddots  & 0 \\\\\n\\vdots    & \\ddots  \t\t&-1  \t &2 & -1\\\\\n0 & \\cdots \t&  0  &-1 & 2\\\\\n\\end{pmatrix}$$\nand a random input vector \\verb|x = numpy.random.rand(n)|. Play around with the dimension $n$ (especially large $n\\geq 10^5$ -- note that you may exceed your hardware capacities for the dense computations).\\\\\n\nFor all cases:\n\\begin{itemize}\n\t\\item \\textbf{Memory:} A number implemented as \\texttt{float} in Python implements double precision and therefore needs \\texttt{64} Bits of storage. What is the number of Gbytes needed to store an $m \\times n$ array of \\texttt{floats}? Print the number of Gbytes which are needed to store the matrix in all cases. For a \\verb|numpy.ndarray| you can type \\verb|A.nbytes| and for the \\texttt{scipy.sparse.csr\\_matrix} you can type \\texttt{A.data.nbytes + A.indptr.nbytes + A.indices.nbytes}.\n\t\\item \\textbf{Computation times:} Measure the time which is needed in each case to compute the matrix-vector product for a random input vector \\verb|x = numpy.random.rand(n)|. In the IPython shell you can simply use the \\textit{magic function} \\verb|%timeit| to measure the time for a certain operation. For example, you can type \\verb|%timeit pythonfunction(x)|. Alternatively you can use the package \\verb|timeit|.\n\\end{itemize}\n%\\begin{figure}[h!]\n%\t\\centering\n\\begin{center}\n\t\t\\includegraphics[width=0.8\\linewidth]{\\PathToMedia/csr-matrix}\\\\\n\t\tExample of a Matrix in CSR Format\n\\end{center}\n%\t\\caption{Example of a Matrix in CSR Format}\n%\t\\label{fig:csr-matrix}\n%\\end{figure}\n\n%\\begin{enumerate}\n%\t\\item  Implement a function \\verb|matfree(x)| which outputs the matrix-vector product $A \\cdot x$ without using the matrix $A$ explicitly.\n%\\end{enumerate}",
    "solution": "\\lstinputlisting[numbers=none]{prog-matvec_solution.py}\n",
    "id": ""
}