{
    "filename": "prog-PowerMethod1.tex",
    "title": "",
    "subtitle": "",
    "coding": "",
    "mathFields": "",
    "tags": "Linear Algebra, Eigenvalues, Python",
    "relatedExercises": "",
    "solutionLength": "",
    "task": "% !TeX spellcheck = en_US\n\\textbf{The Power Iteration and the \\textit{PageRank}}\n%{\\color{navy}The \\textbf{power method} or \\textbf{power iteration} is an eigenvalue algorithm, which, given a matrix $A$, produces a sequence of numbers converging to the largest (in absolute value) eigenvalue of $A$ and a sequence of vectors converging to the corresponding eigenvector. More precisely, the iteration rule is given as follows:\n%\\begin{equation} \\label{eq:power_it}\n%x^{k+1}:=\\frac{Ax^k}{\\|Ax^k\\|_p},~~~\\text{and}~~~\\mu^k:=\\frac{(x^k,Ax^k)_2}{(x^k,x^k)_2}.\n%\\end{equation}\n%Let $\\lambda_1 \\in \\sigma(A)$ be the largest eigenvalue (in absolute value). Then (under certain conditions) we obtain \n%$$ \\mu_k  \\xrightarrow[]{k \\to \\infty}  \\lambda_1 \n%~~~\\text{and}~~\n%x_k \\xrightarrow[]{k \\to \\infty} v_1 \n%~~\\text{with}~~~Av_1=\\lambda_1 v_1.$$\n%\\textit{Remark:} For the normalization step $\\frac{1}{\\|Ax^k\\|_p}$ in the equation above one can choose any $p$-norm $\\|x\\|:=\\left(\\sum_{i=1}^n |x_i|^p\\right)^\\frac{1}{p}$ with $p\\geq 1$; typical choices are $p \\in \\{ 1, 2, \\infty\\}$. Note that the choice $p=2$ corresponds to the Euclidean norm introduced in the lecture.}\n%~\\\\~\\\\\n%\\textbf{Task:}\\\\\n\\begin{enumerate}\n\t\\item \tImplement a function \\verb|power_iteration(A,m,p=1)| which takes as input a matrix $A \\in \\mathbb{R}^{n \\times n}$, a maximum iteration number $m \\in \\N$ and an \\textit{optional} parameter $p$ which determines the order of the $p$-norm and is set to $p=1$ by default. This function shall then return the $m$-th iterates $x_m$ and $\\mu_m$ of the power iteration.\n\t\n\t\\textit{Hints:} \n\t\\begin{itemize}\n\t\t\\item You can use a random distribution $x_0$ as initial guess by calling for example the numpy function $$\\verb|x = numpy.random.dirichlet(np.ones(n),size=1).reshape(n) | $$\n\t\tor simply choose\n\t\t$$\\texttt{x = 1./n * np.ones(n).} $$\n\t\t\\item For the normalization step use the numpy function \n\t\t$$\\verb|numpy.linalg.norm(x, ord=p)|, $$\n\t\twhich allows the choices $p \\in \\{ 1, 2, \\infty\\}$ (among others).\n\t\\end{itemize}\n\n\\item Determine the \\textbf{PageRank} of the web structure given above. Therefore apply your function \\verb|power_iteration(A,m,p=1)| to the PageRank matrix \n$$A:= P = \\alpha P_1 + (1-\\alpha)P_2, $$\nwhere\n $$P_1={ \n\t\\left(  \\begin{tabular}{cccccccccccc}\n\t~ & 1    & 2   & 3    & 4    & 5    & 6 & 7     & 8   & 9  & 10   & 11    \\\\\n\t1 & 1    &~     &  ~   & 1/2  &    ~ & ~ & ~     &  ~  &  ~   & ~ &    ~  \\\\\n\t2 & ~    & ~    &  1   & 1/2  & 1/3  &   & 1/2   & 1/2 & 1/2 &   &    \\\\\n\t3 & ~    & 1    &  ~   &      &      &   &       &     &     &   &    \\\\\n\t4 & ~    &  ~   & ~    &      &  1/3 &   &       &     &     &   &  \\\\  \n\t5 & ~    &  ~   & ~    &      &      & 1 & 1/2   & 1/2 & 1/2 & 1 & 1 \\\\  \n\t6 & ~    &  ~   &  ~   &      & 1/3  &   &       &     &     &   &  \\\\  \n\t7 & ~    & ~    &  ~   &      &      &   &       &     &     &   &  \\\\  \n\t8 &~     & ~    &  ~   &      &      &   &       &     &     &   &  \\\\  \n\t9 & ~    &  ~   &  ~   &      &      &   &       &     &     &   &  \\\\  \n\t10 & ~    &  ~   & ~    &      &      &   &       &     &     &   &  \\\\  \n\t11 & ~    &  ~   & ~    &      &      &   &       &     &     &   &     \n\t\\end{tabular} \\right)\n},\n~~~~P_2 := \\frac{1}{n}ee^T= \\left(\\frac{1}{n}\\right)_{ij}.$$\nPlay around with the damping factor $\\alpha$. What do you observe?\n~\\\\~\\\\\n\\textit{Hint:} For implementing $P_1$ and $P_2$, and thus $P$, you can use this code snippet.\n\\lstinputlisting[numbers=none]{\\PathToMedia/python_examples/pagerank_mats.py}\n\\end{enumerate}\n\n%{\\color{red} - PageRank: But also plot (if possible?) (see  7\\_ PageRank-py.png, python \\_ examples/7 \\_ pagerank.py)\n%\ta) for different aplha in one plot: $||x_k-x_*||$ vs iteration number k\n%\tb) for pages in one plot: pagerank vs alpha}\n\n\n\n\n",
    "solution": "\\lstinputlisting[numbers=none]{prog-PowerMethod1_solution.py}\n",
    "id": ""
}