\section{The Matrix-Vector Product}
Implement a function that takes as input a matrix $A \in \mathbb{R}^{m\times n}$ and a vector $x \in \mathbb{R}^{n}$ and returns the matrix-vector product $Ax$.
~\\

Implement the following ways of doing this:
\begin{enumerate}	
	\item \textbf{Dense:} Input expected as \verb|numpy.ndarray|:\\
		  Assume that the matrix and the vector are delivered to your function as \verb|numpy.ndarray|.
	\begin{enumerate}
		\item Implement the matrix-vector product ``by hand'' using for loops, i.e., \textit{without} using \verb|numpy.dot(A,x)| (or \verb|numpy.matmul(A,x)| or \verb|A@x|).
		\item Implement the matrix-vector product using \texttt{A.dot(x)}, \verb|A@x|, \verb|numpy.matmul(A,x)| or \verb|numpy.dot(A,x)|. 
	\end{enumerate}
	\item \textbf{Sparse:} Matrix expected in \hyperref{https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_row_(CSR,_CRS_or_Yale_format)}{}{}{CSR format}:\\
	Assume that the matrix is delivered to your function as \hyperref{https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.html}{}{}{\texttt{scipy.sparse.csr\_matrix}} object. The vector $x$ can either be expected as \verb|numpy.ndarray| or simply as a Python \texttt{list}. 	
	\begin{enumerate}
		\item Access the three CSR lists via \texttt{A.data, A.indptr, A.indices} and implement the matrix-vector product ``by hand'' using for loops.
		\item Implement the matrix-vector product using \texttt{A.dot(x)} or \texttt{A@x} . %Print the number of Gbytes which are needed to store the matrix in CSR format (have a look at: \texttt{A.data}, \texttt{A.indptr}, \texttt{A.indices}).
	\end{enumerate}
\end{enumerate}


Test your different routines on the matrix $A \in \mathbb{R}^{n \times n}$ given by 
$$A = \begin{pmatrix}
2 & -1 		& 0  &\cdots & 0\\
-1 & 2 		& -1  &\ddots &  \vdots\\
0 & \ddots  		&\ddots   	 &\ddots  & 0 \\
\vdots    & \ddots  		&-1  	 &2 & -1\\
0 & \cdots 	&  0  &-1 & 2\\
\end{pmatrix}$$
and a random input vector \verb|x = numpy.random.rand(n)|. Play around with the dimension $n$ (especially large $n\geq 10^5$).\\

For all cases:
\begin{itemize}
	\item \textbf{Memory:} A number implemented as \texttt{float} in Python implements double precision and therefore needs \texttt{64} Bits of storage. What is the number of Gbytes needed to store an $m \times n$ array of \texttt{floats}? Print the number of Gbytes which are needed to store the matrix in all cases. For a \verb|numpy.ndarray| you can type \verb|A.nbytes| and for the \texttt{scipy.sparse.csr\_matrix} you can type \texttt{A.data.nbytes + A.indptr.nbytes + A.indices.nbytes}.
	\item \textbf{Computation times:} Measure the time which is needed in each case to compute the matrix-vector product for a random input vector \verb|x = numpy.random.rand(n)|. In the IPython shell you can simply use the \textit{magic function} \verb|%timeit| to measure the time for a certain operation. For example, you can type \verb|%timeit pythonfunction(x)|. Alternatively you can use the package \verb|timeit|.
\end{itemize}

%\begin{enumerate}
%	\item  Implement a function \verb|matfree(x)| which outputs the matrix-vector product $A \cdot x$ without using the matrix $A$ explicitly.
%\end{enumerate}
