{
    "filename": "prog-QRAlgorithmn.tex",
    "title": "",
    "subtitle": "",
    "coding": "",
    "mathFields": "",
    "tags": "Linear Algebra, Eigenvalues, Python",
    "relatedExercises": "",
    "solutionLength": "",
    "task": "%\\textbf{The $QR$ Algorithm}\n%\n%auf bild anwenden und einfach mal diagonal(Ainf) nehmen sortieren und mal probieren wie die recovery ist?\n%~\\\\\nThe \\textbf{$QR$-Algorithm} is an eigenvalue algorithm. Thus, it is used to compute eigenvalues and eigenvectors of a matrix $A \\in \\mathbb{R}^{n\\times n}$. It produces a sequence of matrices $\\left(A_{k}\\right)_{k\\in\\mathbb{N}}$. All $A_k$ are similar to $A$ and thus have the same eigenvalues. The iteration is defined as follows:\\\\\n\\begin{minipage}{0.3\\textwidth}\n\t~\n\\end{minipage}\n\\begin{minipage}[c]{0.6\\textwidth}\n\t\\vspace{0.2cm}\n\t\\begin{tabbing}\n\t\t\\qquad \\= \\qquad \\= \\qquad \\kill\n\t\t$A_0=A \\in \\mathbb{R}^{n\\times n}$\\\\\n\t\t\\textbf{for} $k=0,\\ldots ,\\infty$\\ : \\\\[0.3em]\n\t\t\\> $Q_{k+1}R_{k+1}:=A_{k}$ ~~~{\\small ($QR$ decomposition)} \\\\[0.3em]\n\t\t\\> $A_{k+1}:=R_{k+1}Q_{k+1}$ \n\t\\end{tabbing}\t \n\\end{minipage}\n~\\\\~\\\\\nIf the absolute values of the eigenvalues of $A$ are distinct, one can show that $A_\\infty :=\\lim_{k\\to\\infty} A_k$ is a diagonal matrix. In this case, the eigenvalues of $A$ are the diagonal elements of $A_\\infty$.\n \n~\\\\\n\\textbf{Task:}\n\\begin{enumerate}\n\t\\item Implement the QR eigenvalue algorithm as a function \\verb|eig(A,m)|. The function shall take as input a matrix $A\\in \\mathbb{R}^{n\\times n}$ and a maximum iteration number $m\\in\\mathbb{N}$. It shall return the diagonal of the last iterate $A_m$. For the $QR$ decomposition you can use the Gram-Schmidt algorithm from previous sheets which we have implemented as a function \\verb|QR(A)| or an appropriate Python routine. \\\\~\\\\\n\t\\textit{Hint: } You can access the diagonal of a \\verb|numpy.array| by \\verb|A.diagonal()|.\n\t\\item Test your algorithm on a random matrix $A\\in \\mathbb{R}^{n\\times n}$. In order to generate such a random matrix use the following code snippet:\\\\[2pt]\n\t\t\\verb|def A_gen(n): |\\\\\n        \\textcolor{white}{~~~~}\\verb|from numpy as np|\\\\\n        \\textcolor{white}{~~~~}\\verb|from scipy.linalg import qr|\\\\\n        \\textcolor{white}{~~~~}\\verb|A = np.random.rand(n,n)|\\\\\n\t\t\\textcolor{white}{~~~~}\\verb|Q, R = qr(A)|\\\\\n\t\t\\textcolor{white}{~~~~}\\verb|Lambda = np.diag(np.arange(1,n+1))|\\\\\n\t\t\\textcolor{white}{~~~~}\\verb|A = Q @ (Lambda @ Q.T)|\\\\\n\t\t\\verb|return A|\n\t\\item Find a routine in \\texttt{Scipy} to compute the eigenvalues and -vectors of a matrix. Test the routine on multiple examples, especially for higher dimensions. Compare to your algorithm.\n\t\n\\end{enumerate}\n\n\n\n\n\n\n",
    "solution": "\\lstinputlisting[numbers=none]{prog-QRAlgorithmn_solution.py}\n",
    "id": ""
}