{
    "filename": "prog-GramSchmidt.tex",
    "title": "",
    "subtitle": "",
    "coding": "",
    "mathFields": "",
    "tags": "Linear Algebra, Python",
    "relatedExercises": "",
    "solutionLength": "",
    "task": "% !TeX spellcheck = en_US\n\\textbf{Gram-Schmidt algorithm ($QR$ factorization)}\n\n{\\color{navy}\nThe Gram-Schmidt algorithm is an algorithm that can be used to compute a reduced (sometimes also called ``thin'' or ``economic'') QR-decomposition of a matrix $A \\in \\mathbb{R}^{m\\times n}$ with $m\\geq n$ and $\\text{rank}(A) = n$, i.e., of a matrix whose columns are linearly independent.\\\\\nThe basic idea is to successively \nbuilt up an orthonormal system from a given set of linearly independent vectors; in our case the columns of \n$A = [a_1, \\dots, a_n] \\in \\mathbb{R}^{m\\times n}$.\nWe choose the first column as starting point for the algorithm and set $\\widetilde{q_1} := a_1$. \nOf course, in order to generate an orthogonal matrix $Q$ we have to rescale the vector and set\n$q_1 := \\frac{\\widetilde{q_1}}{\\| \\widetilde{q_1} \\|}$.\nThe successive vectors $\\widetilde{q}_k$ are generated by\nsubtracting all the ``shares'' $a_k^\\top q_\\ell\\cdot q_\\ell$ (=$\\text{proj}_{q_\\ell}(a_k)$) of the previous vectors $q_\\ell$ from the column $a_k$, i.e.,\n$$\n\\widetilde{q}_k := a_k - \\sum_{\\ell = 1}^{k-1} a_k^\\top q_\\ell \\,\\, q_\\ell.\n$$\n\n\nThe following algorithm computes a \\textit{reduced} QR-decomposition of some matrix $A \\in \\mathbb{R}^{m \\times n}$.\\\\\n~\\\\\n$r_{11} \\gets \\| a_1 \\|$\\\\\n$q_1 \\gets \\frac{a_1}{r_{11}}$\\\\\n~\\\\\n\\textbf{for} $k = 2, \\dots, n$  \\\\\n{\\color{white}ind}\\textbf{for} $\\ell = 1,\\dots, k-1$ \\\\\n{\\color{white}ind}{\\color{white}ind}$r_{\\ell k} \\gets a_k^\\top q_\\ell$\t\\\\\n~\\\\\n{\\color{white}ind}$\\widetilde{q}_k \\gets a_k - \\sum _{\\ell=1}^{k-1} r_{\\ell k} \\, q_\\ell$\\\\\n{\\color{white}ind}$r_{kk} \\gets \\| \\widetilde{q}_k \\|$\\\\\n{\\color{white}ind}$q_k \\gets \\frac{\\widetilde{q}_k}{r_{kk}}$\\\\\n}\n~\\\\\n\\textbf{Task:} \n\\begin{enumerate}\n\t\\item Implement the Gram-Schmidt algorithm as a function \\verb|qr_factor(A)|, which takes a matrix $A$ as input and returns the matrices $\\widehat{Q}$ and $\\widehat{R}$.\n\t\\item Run your algorithm on an example matrix (e.g., \\texttt{numpy.random.rand(m,n)}) and test your result by computing $\\widehat{Q}^\\top \\widehat{Q}$ and $\\widehat{Q}\\widehat{R} - A$, where the first should yield the identity and the latter a zero-matrix.\n\t\\item Find a SciPy routine to compute the $QR$ decomposition (for the reduced $QR$ you may need to set the parameters accordingly).\n\\end{enumerate}\n\n\\textit{Hint: } You can use \\texttt{numpy.allclose()} to check whether two \\texttt{numpy.ndarray}'s are equal up to a certain tolerance.\n",
    "solution": "\\lstinputlisting[numbers=none]{prog-GramSchmidt_solution.py}\n",
    "id": ""
}