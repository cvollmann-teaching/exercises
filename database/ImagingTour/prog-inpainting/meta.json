{
    "filename": "prog-inpainting.tex",
    "title": "",
    "subtitle": "",
    "coding": "",
    "mathFields": "",
    "tags": "Least Squares Problems, Python",
    "relatedExercises": "",
    "solutionLength": "",
    "task": "\\textbf{\\normalsize More General Regularization Terms and \\hyperref{https://en.wikipedia.org/wiki/Inpainting}{}{}{Image Inpainting}}\n\n~\\\\\n{\\color{navy}\n\t\\textbf{Background:}\\\\\n\tBased on the idea of Tikhonov regularization we can use more general regularization terms by transforming the vector $x$ with some matrix $G\\in\\Rmn$. Specifically, let us consider the more general regularized problem\n\t\\begin{equation} \\label{prob:regularized_leastsquares}\n\t\\min_{x\\in \\Rn} \\|Ax-b\\|_2^2 + \\frac{\\delta}{2}\\|Gx\\|_2^2,~~~\\delta > 0 ~\\text{small}.\n\t\\end{equation}\n\tThe corresponding ``regularized'' normal equation then reads as \n\t\\begin{equation}\\label{eq:regularized_normaleq}\n\t(A^TA  + \\delta G^\\top G)x = A^Tb. \n\t\\end{equation}\n\tObserve that for $G = I$ we obtain the standard Tikhonov (or $L^2$-) regularization. We easily see that if $G^\\top G$ is positive definite, then so is $A^TA  + \\delta G^\\top G$ for positive $\\delta$, so that \\eqref{eq:regularized_normaleq} is uniquely solvable.\\\\~\\\\ \n\tWe will apply this framework to the problem of \\hyperref{https://en.wikipedia.org/wiki/Inpainting}{}{}{image inpainting}. Therefore assume you are given the deteriorated image $b$, which is obtained from the \\underline{unknown} original image $x$ through the following masking operation\n\t\\begin{equation} \\label{eq:masking_operation}\n\t\tb_i = \\begin{cases}\n\t\tx_i & i \\in \\texttt{indices},\\\\\n\t\t0 & \\text{else},\n\t\t\\end{cases}\n\t\\end{equation}\n\twhere \\texttt{indices} is a list of random pixels. In words, the pixels in \\texttt{indices} survived, the rest is set to zero and therefore lost. We want to recover those lost pixels. Note that the images are considered being flattened and thus vectors, so that the masking operation \\eqref{eq:masking_operation} can be written as a matrix-vector product\n\t$$b = Ax $$\n\tfor some quadratic matrix $A$. You will see below that $A$ is not of full rank, so that we cannot simply solve this equation. Instead, we will seek for solutions of the regularized least squares problem \\eqref{prob:regularized_leastsquares} by solving the linear equation \\eqref{eq:regularized_normaleq}. \n\t~\\\\\n\tFor this purpose will stick to a particular $G$ which is related to what is called Sobolev (or $H^1$-) regularization. Specifically we consider the 1-d finite difference quotient\n\t\\begin{equation}\\label{eq:G}\n\t G = \\begin{pmatrix}\n\t  1 & &  &  \\\\\n\t  -1 & 1 &   &\\\\\n\t   &\\ddots&\\ddots & \\\\\n\t   & &-1 & 1\\\\\n\t \\end{pmatrix} \\in \\R^{(n+1)\\times n},\n\t\\end{equation}\n\twhich has $1$ on the main diagonal, $-1$ on the first lower off-diagonal, $0$ everywhere else and is of dimension $(n+1)\\times n$. Then, given the measured image $b$, the masking operator $A$ (we assume that we know which pixels are original) and the regularization $G$ we reconstruct the unknown image $x$ by solving equation \\eqref{eq:regularized_normaleq}. See Figure below for an example experiment.\n}\n\\begin{center}\n\t\\includegraphics[trim={7cm 10.2cm 7cm 10.2cm},clip, width=1.\\textwidth]{least-squares/Image_Inpainting}\\\\~\\\\\n\t\\textit{Example experiment.}\n\\end{center}\n\\newpage\n\\textbf{Step by Step}\\\\\nFirst note that due to the high dimensional image data you need to work with sparse matrices (\\texttt{scipy.sparse}); specifically you should work with the CSR format.\n\\begin{enumerate}\n\t\\item \\textbf{Choose original image:} Choose an image and load it in gray-scale as $H\\times W$ \\texttt{numpy.ndarray} using the code snippet:\n\t\\lstinputlisting[firstline =7,lastline=13]{prog-inpainting_solution.py}\n\t\\item \\textbf{Masking:} Write a function \n\t$$\\texttt{b, indices = masking(img, percentage)},$$\n\twhich takes as input an image \\texttt{img} as $H\\times W$ \\texttt{numpy.ndarray} and a number \\texttt{percentage} $\\in (0,1)$ which indicates the percentage of pixels that are randomly kept. It shall return the masked image $b$ as an $n:=(H\\cdot W)$-dimensional vector and the list \\texttt{indices} $\\subset \\{0,\\ldots, n-1\\}$ indicating which pixels are original.\n\t\\begin{itemize}\n\t\t\\item Ultimately, the image needs to become a vector. For this purpose you can use for example the method \\texttt{.ravel()}. No matter which method/function you choose, be aware of how the vector is flattened (standard is often: row-major/C-style order).\n\t\t\\item To generate a random set of indices based on the parameter \\texttt{percentage} have a look at the function \\texttt{numpy.random.choice}.\n\t\\end{itemize}\n\t\\item \\textbf{Solving:} Write a function \n\t $$\\texttt{reconImg = inpainting(b, indices, delta, G)},$$\n\t which expects a deteriorated image $b$ as vector of length $n$, a list \\texttt{indices} $\\subset \\{0,\\ldots, n-1\\}$ of length $\\leq n$ indicating which pixels are original, a regularization parameter \\texttt{delta} $>0$ and a matrix \\texttt{G} $\\in \\R^{m\\times n}$. It then solves \\eqref{eq:regularized_normaleq} and returns the solution as an $n$-dimensional vector \\texttt{reconImg}.\n\t \\begin{itemize}\n\t \t\\item The sparse  $(n \\times n)$ masking matrix $A$ is zero everywhere except for $a_{ii} = 1$ for $i \\in$\\texttt{indices}. For example, you can easily implement this matrix with  \\texttt{sparse.coo\\_matrix} and then transform it to CSR format via its method \\texttt{.tocsr()}.\n\t \t\\item You can implement the sparse matrix $G$ from \\eqref{eq:G} with the help of the function \\texttt{scipy.sparse.eye}.\n\t \t\\item You can then solve the system \\eqref{eq:regularized_normaleq} with \\texttt{scipy.sparse.linalg.spsolve}.\n\t \\end{itemize}\n \t\\item \\textbf{Analysis:} \n \t\\begin{itemize}\n \t\t\\item Play around with different choices for the parameters \\texttt{delta} and \\texttt{percentage}.\n \t\t\\item You can plot your images (original, masked, reconstructed) with $$\\texttt{matplotlib.pyplot.imshow((...).reshape(H,W), cmap='gray')}.$$\n \t\t\\item Bonus: Try to recover the image with standard Tikhonov regularization, i.e., $G=I$. Do you have an idea why this does not work here?\n \t\t\\item Bonus: With this choice of $G$, you get flattening artifacts in one dimension (horizontal or vertical depending on your flattening approach) and at the boundary of the reconstructed image. Do you have an idea why? \n \t\\end{itemize}\n \\item \\textbf{Bonus:} Instead of removing randomized set of pixels, remove a patch of the image. Can you reconstruct it?\n\\end{enumerate}\n\n\n",
    "solution": "\\lstinputlisting[numbers=none]{prog-inpainting_solution.py}\n",
    "id": ""
}